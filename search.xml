<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>程序员应该知道的97件事-8 童子军规则</title>
      <link href="/2020/ckdu1wdb4000027xfawxsh0l6/"/>
      <url>/2020/ckdu1wdb4000027xfawxsh0l6/</url>
      
        <content type="html"><![CDATA[<p>原文链接: <div><a class='link-card' title='https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_08/' href='https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_08/' target="_blank" rel="noopener"><div class='left'><i class='fas fa-link'></i></div><div class='right'><p class='text'>The Boy Scout Rule</p><p class='url'>https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_08/</p></div></a></div></p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>童子军规则</span></h2><p>童子军有一条规则：总是保持营地比你发现它时还要干净。如果你发现地上一团糟，不管是谁弄脏的，你都要打扫干净。你有意为下一组露营者改善周围环境。事实上这条规则的原始版本是出自罗伯特·史蒂芬生·史密斯·贝登堡(童子军运动创始人)，内容是尝试让这个世界比你发现它的时候变的更好一点。</p><p>假如我们在代码中也遵循这条规则：总是在提交代码时比上次拿到的模块代码更整洁。不管谁是原始作者，假如我们总是做出努力去提高模块，即使每次一点点。那将会是什么结果呢？</p><p>我认为如果我们遵循这条简单的规则，我们会看到软件系统持续恶化的终结。相反，我们的系统随着进化会越来越好。我们将看到团队将系统作为一个整体来对待，而不是各自手头的那一小部分。</p><a id="more"></a><p>我认为这个规则的要求并不过分。你不必在提交代码时让每个模块都完美。你只需要简单的让它比你获取代码时好那么一点。当然这意味着你添加的任何代码都必须是整洁的。这也意味着你提交模块时至少要整理其他一件事情。你可能简单优化了一个变量名称，或者把一个超大函数拆成了两个小函数。你可能修复了一个循环依赖，或者加了一个接口来解耦策略和细节。</p><p>坦率的讲，这对我来说再普通不过了，就像便后要洗手，或者把垃圾扔到垃圾筒里而不是扔到地上一样。的确，把代码搞遭的行为和乱扔垃圾一样不被社会所接受，都是不应该做的事情。</p><p>但是不止这些，关心你的代码是一件事情，关心团队的代码是另一件事情。团队应该互相帮助，互相整理。他们应该遵守童子军规则，因为它对所有人都好，不仅仅是对他们好。</p><p>By <div><a class='link-card' title='https://blog.cleancoder.com/' href='https://blog.cleancoder.com/' target="_blank" rel="noopener"><div class='left'><img src=https://blog.cleancoder.com/assets/clean_code_72_color.png></div><div class='right'><p class='text'>Uncle Bob</p><p class='url'>https://blog.cleancoder.com/</p></div></a></div></p>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员应该知道的97件事-7 当心共享</title>
      <link href="/2020/ckddwsgpo00007gxf6u1f5we1/"/>
      <url>/2020/ckddwsgpo00007gxf6u1f5we1/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<div><a class='link-card' title='https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_07/' href='https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_07/' target="_blank" rel="noopener"><div class='left'><i class='fas fa-link'></i></div><div class='right'><p class='text'>Beware the Share</p><p class='url'>https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_07/</p></div></a></div></p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>当心共享</span></h2><p>那是我在公司的第一个项目，我刚刚完成我的学位，急于证明自己，每天工作到很晚，检查已有的代码。当我做完第一个功能开发，我格外小心地把学到的所有东西落实到位，评论、日志、尽可能的抽离共享代码到库中。然后对我认为已经准备好的代码做评审时，使我意识到重用是不被赞同的。</p><p>怎么会这样呢？学校里重用被认为是高质量软件工程的缩影。我读过的文章和教科书，以及资深的软件工程师都是这样告诉我的。一切都错了吗？</p><p>原来是我漏掉了一个关键信息：</p><emp>上下文</emp><p>系统中两个截然不同的部分以相同的方式执行某种逻辑，并没有我们想象中的那么重要。直到我把这些库中共享代码抽离出来为止，这些部分的代码互相是不依赖的。每一部分都可以独立演化。每一部分都可以修改自己的逻辑以满足系统日益变化的业务需求。四行相似的代码是偶然的–暂时的异常、一个巧合。直到我出现。</p><a id="more"></a><p>我构建的共享代码就像把彼此的鞋带绑在了一起。这样的话，一个业务领域的步骤如果不与其他业务同步就不能被创建出来。功能独立的维护成本通常是微不足道的，但是通用库则需要多一个数量级的测试。</p><p>当我减少了系统中的代码行数，却增加了一堆的依赖。这些依赖的上下文很重要–如果已经被本地化了，那么它可能是合理的，并且有一些积极的价值。如果这些依赖关联不大，即使它们看起来很好，但也会使系统陷入更大的问题中。</p><p>这些错误是隐蔽的，因为它们的核心内容听起来像一个好主意。当应用到正确的上下文中，这些技术是有价值的。但是在错误的上下文中，它们增加的消耗比价值更大。当碰到一段已经存在的代码，不知道都是哪些不同部分在使用它，我对哪些内容该共享会更加小心。</p><p>当心共享代码。仔细检查上下文。只有这样才能继续。</p><p>By <div><a class='link-card' title='https://www.linkedin.com/in/udidahan/?originalSubdomain=il' href='https://www.linkedin.com/in/udidahan/?originalSubdomain=il' target="_blank" rel="noopener"><div class='left'><img src=https://cdn.jsdelivr.net/gh/yfzhang-nk/cdn-assets@master/logo/128/linkedin.png></div><div class='right'><p class='text'>Udi Dahan</p><p class='url'>https://www.linkedin.com/in/udidahan/?originalSubdomain=il</p></div></a></div></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><span class='p blue'>单词</span></h2><blockquote class="pullquote [class]"><p><span class='p green'>put in place</span> 到位；落实到位；正在实施<br><span class='p green'>up until</span> 一直到…为止<br><span class='p green'>negligible</span> adj. 微不足道的，可以忽略的<br><span class='p green'>be held in check</span> 牵制于人<br><span class='p green'>insidious</span> adj. 阴险的；隐伏的；狡猾的</p></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><span class='p blue'>个人观点</span></h2><p>本文给人的启发就是抽取共用代码的时候要当心，有可能他们其实没有啥关系，只是代码看起来有点相似而已，作者给出了区分共享代码的关键判断点，看上下文。不过我个人觉得这是个正确的废话，判断上下文是否适合共享代码，还是会存在很大的主观性，实际情况还是会碰到扯皮的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员应该知道的97件事-6 重构之前</title>
      <link href="/2020/ckczxqjo00000rbxf7obod820/"/>
      <url>/2020/ckczxqjo00000rbxf7obod820/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_06/" title="" target="">Before You Refactor</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>重构之前</span></h2><p>某些时刻每个程序员需要重构已有的代码。但是在做重构之前请想清楚一下几点，这样会帮你和其他人省很多时间（或者痛苦）：</p><ul><li><p>重构最好的方法应该从观察已有的代码库和相关测试案例。这会帮助你了解当前代码的优点和缺点，以保证能保留已有的优点和避免错误。我们都认为我们会比现有系统做的好…直到完成，发现我们有些事比以前做的并不比以前好，甚至更糟，因为我们没有从之前的错误中吸取教训。</p><a id="more"></a></li><li><p>避免重写所有的诱惑。最好重用尽量多的旧代码。不管代码多丑，但只要是被测试过和评审过的代码就可以重用。丢弃旧代码-尤其是已经上线的-意味着你丢弃了数月的测试和久经考验的代码，里面可能有很多背景和你不知道的缺陷修复。如果你不考虑这些，你写出来的代码就会出现很多难解的问题，而这些问题其实已经在旧代码中被修复了。这会浪费很多时间、精力和多年来获得的知识。</p></li><li><p>多次增量修改好于一次重大调整。增量调整可以让我们容易从反馈中（比如测试）获取对系统的影响。一次修改后出现上百个测试失败，肯定是不好的，这会导致我们感到挫折和压力，从而做出错误决定。一次两三个测试失败是容易处理的，提供更可管理性的方法。</p></li><li><p>每次迭代结束，保证现有测试案例通过是很重要的。如果现有测试不能充分覆盖你的变动，就要新增测试案例。没有经过应有的考虑就不要轻易抛弃旧代码的测试案例。表面上看其中一些测试可能并不适用新的设计，但是它们很值得深挖其中特殊测试案例存在的原因。</p></li><li><p>抛去个人喜好和自我。如果没有问题，为什么要去修复它？代码风格和结构不满足我们的喜好，不是一个好的重构理由。同样，你认为会比上一个程序员做的更好，这也不是一个好的理由。</p></li><li><p>追求新技术也不是重构的充分条件。最糟糕的重构原因就是当前代码已经远远落后今天最酷炫的技术，而且我们认为最新的语言和框架能做更多高级的事情。除非成本收益分析说明新语言或框架能够在功能性、维护性和创造性上产生重要提升，否则保持现状就好。</p></li><li><p>记住人总是会犯错的。重构永远不能保证新代码更好，或者和原来一样好。我曾经看到过，也经历过不少失败的重构。人非圣贤孰能无过。</p></li></ul><p>By <a href="https://www.linkedin.com/in/rajith-muditha-attapattu/" title="" target="">Rajith Attapattu</a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><span class='p blue'>单词</span></h2><blockquote class="pullquote [class]"><p><span class='p green'>take stock of</span> 观察、估量<br><span class='p green'>temptation</span> n. 引诱；诱惑物<br><span class='p green'>take … into account</span> 考虑；重视；体谅<br><span class='p green'>gauge</span> v. 测量；估计</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员应该知道的97件事-5 美在简单之中</title>
      <link href="/2020/ckcx1gc2s0000ydxfhksgh8qk/"/>
      <url>/2020/ckcx1gc2s0000ydxfhksgh8qk/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_05/" title="" target="">Beauty Is in Simplicity</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>美在简单之中</span></h2><p>有一句格言是所有软件开发者应该知道并且牢记于心的：</p><blockquote><p>风格、和谐、优雅、节奏之美取决于简单。</p><footer><strong>柏拉图</strong></footer></blockquote><p>一言以蔽之，这句话概括出了软件开发者渴求的价值所在。</p><a id="more"></a><p>对于代码，我们有很多追求的东西：</p><ul><li>可读性</li><li>可维护性</li><li>开发速度</li><li>美感<br>柏拉图想告诉我们实现这些品质的因素是简单。</li></ul><p>什么是漂亮的代码？这是一个非常主观的问题。正像很多观念认知取决于我们的背景一样，美的感知也极大的依赖于我们的背景。学习艺术的人和学习科学的人对美有不同的视角（至少有这个倾向）。艺术专业的人更倾向于通过比较软件和艺术工作来寻找美感，科学专业的人更强调谈论对称和黄金比例，试图把事情简化为公式。以我的经验来看，简洁性是双方论证的基石。</p><p>想想你学习过的源代码。如果你还没有读过别人的代码，立刻停止读这篇文章，找一些开源的代码学习学习。真的，我是认真的！去网上搜索哪些知名专家写的代码，只要是你熟悉的语言就行。</p><p>你回来了？好的，我们说到哪了？哦，是的…我发现那些能引起我共鸣的、我认为漂亮的代码都有很多共性。其中最主要的就是简洁性。我发现应用或者系统不管有多复杂，每个独立部分都保持着简洁性。这些简单的对象都拥有相似的简洁性：单一职责、方法高内聚、方法命名自描述。有人认为5-10行一个短方法有点极端，甚至有些语言特性使得方法很难几行内实现功能。尽管如此，这样的简洁性应该是我们追求的目标。</p><p>漂亮代码的底线是简单。每个独立的部分都应该保持简单：拥有简单的职责，与系统其他部分保持简单的关联。通过干净整洁、可测试的代码，在系统的整个生命周期内保持高效的开发速度，这才是让我们的系统能够承受住时间考验的方法。美来源于简单，并因简单被人们发现。</p><p>By <a href="https://www.linkedin.com/in/joelmheim/" title="" target="">Jorn Olmheim</a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><span class='p blue'>单词</span></h2><blockquote class="pullquote [class]"><p><span class='p green'>keep close to one’s heart(s)</span>  牢记于心、放在心上<br><span class='p green'>aspire to</span> 渴求<br><span class='p green'>formulae</span>  n. 公式（formula的复数)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员应该知道的97件事-4 自动化你的编码标准</title>
      <link href="/2020/ckcom8une0003toxfdp0qcfqv/"/>
      <url>/2020/ckcom8une0003toxfdp0qcfqv/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_04/" title="" target="">Automate Your Coding Standard</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>自动化你的编码规范</span></h2><p>你可能有过这样的经历，项目一开始时，每个人都有很多想法-我们称为新项目决议。这些决议经常会记录到文档里。关于代码的决议最终会称为项目的代码规范。在启动会议上，开发负责人会浏览文档，最好的情况，每个人都同意会尝试遵守它。然而，一旦项目开始，这些好的想法都会一个一个被抛弃。当最终交付项目时，代码看起来一团糟，没有人知道怎么变成这样的。</p><p>是什么时候变糟的？大概在启动会议时，项目成员有些不太在意，其他人没有理解这点，更糟糕的，有些人根本就不同意这些规范，可能已经开始计划不服从这些规范。最后，有些人抓住了重点而且也同意，但是当项目压力过高时，他们不得不放任不管规范了。格式良好的代码并不会在客户那里获得加分，他们只是想要更多功能。而且加入代码规范不是自动化的，遵守它是一项很无聊的任务。尝试下缩进一个排版混乱的类，你就能明白自动化的好处了。</p><a id="more"></a><p>既然有这些问题，我们为什么还要一开始就制定编码规范呢？使用统一的代码规范的一个原因是，可以避免某些人通过使用自己的编码风格“独占”一段代码。我们想要阻止开发者使用反模式，以此避免一些常见Bug。总之，代码规范能够使在项目中工作变的轻松，从头到尾都可以保持开发速度。达到这个效果的前提是每个人都遵守它，否则就没有用了，比如有的人使用三个空格缩进，另一些人用四个缩进。</p><p>有很丰富的工具被用来生成代码质量报告或者是文档化维护代码规范，但这都不能全面解决问题。一定要把它自动化，在任何地方尽可能的强制执行。以下有一些示例：</p><ul><li>保证你的代码规范检查是构建过程中的一环，以此可以让每个人都能在编译的时候自动的运行一遍规范检查。</li><li>用静态代码分析工具去扫描一遍代码中非预期的反模式。一旦发现终止构建。</li><li>学习如何配置这些工具，以便你可以定制你自己的扫描策略。</li><li>不要只测量代码测试覆盖率，还要自动化的检查结果。同样的，一旦发现测试覆盖率过低，就终止构建。</li></ul><p>尽量自动化所有你认为重要的地方。你不可能把所有你关心的点都自动化起来。有一些地方你无法做到标记或修复的，把它们写到一个指导手册里，作为代码规范自动化的补充，但是你要接受这个事实：你的同事可能不会那么严格遵守手册中的内容。</p><p>最后，代码规范应该是动态的而不是静态的。随着项目的演进，项目需求会变，一开始看起来很聪明的做法，几个月后就看起来没有那么必要了。</p><p>By <a href="https://github.com/filipvanlaenen" title="" target="">Filip van Laenen</a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><span class='p blue'>单词</span></h2><blockquote class="pullquote [class]"><p><span class='p green'>quite often</span> 经常<br><span class='p green'>get underway</span>  开始、启程<br><span class='p green'>in all</span>  总之<br><span class='p green'>diligently</span> 勤奋的，勤勉的</p></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><span class='p blue'>个人观点</span></h2><p>除了代码规范应该自动化外，其他东西也可以学习自动化的方式。比如公司的价值观，个人的思维模式（或者行为准则）。大脑需要慢系统才能完成的事情，借助自动化这个外脑，在快系统中就能够得出正确决定。</p>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员应该知道的97件事-3 想想用户会怎么做</title>
      <link href="/2020/ckcfwsxmd0000toxf8pbubn7a/"/>
      <url>/2020/ckcfwsxmd0000toxf8pbubn7a/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_03/" title="" target="">Ask What Would the User Do? (You Are not the User)</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>问问“用户会怎么做”</span></h2><p>我们倾向于假设其他人和我们思考方式一样，但是他们不会。心理学家称这个现象叫做虚假同感偏差。当人们思考或者行事跟我们不一样时，我们潜意识上很容易在某种程度会给他们打上缺陷的标签。</p><p>这种偏见解释了程序员们为什么很难把自己放到用户的位置上，用户也不会像程序员一样想问题。首先，他们很少花时间使用电脑。他们不知道也不关心电脑如何工作。这就意味着程序员们解决问题时采用了一些习以为常的技术，用户们却不会使用。在页面接口上，用户不会识别出图示和线索，尽管这些是程序员们经常使用的。</p><a id="more"></a><p>找出用户是如何思考的最好办法就是观察他们。要求用户使用你开发的软件，完成一项任务。确保这是一个真正的任务：“加总一列数据”，“计算你上个月的收支”。避免太详细的任务，比如，请选择这些电子表格单元格，在下面输入一个求和公式，这个任务给了很大暗示。让用户说说他的操作流程。不要打断或者试图帮助他。要不停思考“他/她为什么这么做”。</p><p>你会注意到用户做的这些事情的核心都是类似的。他们试图采用相同的顺序完成任务，并且在相同的地方犯一样的错误。你就应该设计这个核心操作了。这个不同于设计会议，因为在那样的会议上，人们更倾向于听到“如果用户想…该怎么办？”。这会导致复杂的功能并不是用户想要的。观察他们减少这种问题。</p><p>你会碰到用户被卡住的情况，当你卡住时，你会到处看看；当用户被卡住时，他们只会缩小他们的关注点。对于他们来说在屏幕的其他地方看到解决方案就变得更困难。这就是为什么帮助文字对于用户交互设计是一个不好的解决方法。如果你必须添加指示或者说明文档，保证把它们放在对的地方，比如靠近会出现问题的区域。正因为用户有限的注意力，工具栏提示会比帮助文档有用的多。</p><p>用户往往会蒙混过关。他们找到一个有效的方法他们就会坚持这么用下去，而不管这个方法多复杂。所以最好给用户提供一个真正明显的方法，而不是提供两三捷径。你还会发现用户说他们想要的，和他们真正想要的之间存在差异。令人担忧的是收集用户需求的通用方法是问他们。这也是为什么说获取用户需求最好的办法是观察他们。花一小时观察用户比猜测用户想要什么能获取更多的信息。</p><p>By <a href="https://book.douban.com/subject/5394309/" title="" target="">Giles Colborne</a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><span class='p blue'>单词</span></h2><blockquote class="pullquote [class]"><p><span class='p green'>for a start</span>  首先；作为开始<br><span class='p green'>get stuck</span>  v. 受骗；被卡在…；被堵…<br><span class='p green'>muddle through</span>  终于应付过去；混过去<br><span class='p green'>stick with</span>  坚持；继续做；保持联系<br><span class='p green'>convoluted</span> adj. 复杂的；费解的；旋绕的  </p></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><span class='p blue'>个人观点</span></h2><p>“Users tend to muddle through”，这点我深有体会，曾经就有用户告诉我们，不这样做，他们也会有其他办法实现想要的功能，只是会复杂一些，用户并不是笨，只是懒，懒的去发现你设计的捷径，只要有一个方法能实现自己的要求，就可以了，没有必要花时间去找到更多方法。相反，用户使用了复杂的方法后，反而会抱怨我们太笨，为什么不那样设计，要绕这么大一个弯子。</p>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员应该知道的97件事-2 应用函数式编程原则</title>
      <link href="/2020/ckceme0r50006njxfabeu4lg6/"/>
      <url>/2020/ckceme0r50006njxfabeu4lg6/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_02/" title="" target="">Apply Functional Programming Principles</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>应用函数式编程原则</span></h2><p>函数式编程(FP)最近又受到了主流编程社区的喜爱，部分原因是对于来自多核的挑战，函数范式的特性占有有利的位置。尽管这个原因的确是函数式编程很好的一个应用，但不是我给你推荐函数式编程的原因。</p><p>掌握函数式编程可以极大地提高你在其他上下文上写代码的质量。如果你能深入理解和应用函数范式，你的设计会拥有很高的引用透明性。</p><a id="more"></a><p>引用透明性是一个很好的特性：表示一个函数针对相同的输入，始终产生相同的结果，而不管是在什么地方和什么时候调用。也就是说，函数的求值很少依赖（理想中是完全不依赖）可变状态的副作用。</p><p>命令式代码的主要缺陷来自可变的变量。读到这里的每个程序员都有这样的经历：在某个特殊情况下某些值不是期望的。可见性语义可以帮助我们减少这类问题，至少可以缩小范围，但真正的罪魁祸首是程序设计中滥用了变量。</p><p>在这个方面，我们确实没有从中获取太多帮助。面向对象默认使用这样的设计，因为他们经常展示由多个相关且长生命周期的对象图表组成的示例，美其名曰赋值方法，这样做其实是很危险的。但是，通过巧妙的测试驱动开发的设计，特别是确保“模拟职责，而不是对象”，可以消除不必要的可变性。</p><p>最终结果应该是这样一个设计：创建众多小函数，每个函数拥有自己的职责分配，按照输入的参数输出结果，而不是引用可变的成员变量。这样做产生的缺陷少，此外它们还容易调试，因为很容易定位该设计引入的标志值，比通过特定的上下文推断错误的赋值要好。这将大幅度增加引用透明性，想让这种意识深入骨髓，没有比学习函数式编程更好的办法了，因为这个在函数式编程中是作为标准出现的。</p><p>当然，这个方法不是在所有场景下都是最优的。比如，在面向对象系统中，这种风格在领域模型开发（例：打破商业规则的复杂度）上比用户界面开发更能产出更好的结果</p><p>掌握了函数式编程范式，你将更明智的把本章内容应用到其他领域。你的对象系统与引用透明性更能产生共鸣，跟函数式对等方式的接近程度超乎你的想象。实际上，有人断言函数式编程和面向对象编程是相互映射的两端，是计算机领域里的阴阳两极。</p><p>By <a href="https://www.linkedin.com/in/egarson/" title="" target="">Edward Garson</a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><span class='p blue'>单词</span></h2><blockquote class="pullquote [class]"><p><span class='p green'>be attributed to</span>  归因于…<br><span class='p green'>culprit</span>  n. 犯人，罪犯<br><span class='p green'>act on</span>  对…起作用；按照…行事<br><span class='p green'>rogue value</span> 维基百科上显示为sentinel value的别名，表示标记值</p></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><span class='p blue'>个人观点</span></h2><p>函数式编程的特性我还没有深入的理解，此时不置评论。不过我相信，函数式编程有很好的特性，但软件工程上没有银弹，任何的设计都有适用的范围，使用前先深入了解它。</p>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每个程序员应该知道的97件事</title>
      <link href="/2020/ckceme0qt0000njxf7ug6aojn/"/>
      <url>/2020/ckceme0qt0000njxf7ug6aojn/</url>
      
        <content type="html"><![CDATA[<p>极客时间上购买了左耳听风的专栏，就是陈皓（左耳朵耗子）一个关于技术、成长、管理的文章合集，内容确实是丰富。</p><p>首先作者提供了一个程序员练级的方法，叫做ARTS，就是每周完成一个ARTS：</p><ol><li>Algorithm：每周至少做一道算法题；</li><li>Review：阅读并点评至少一篇英文技术文章；</li><li>Tip：学习至少一个技术技巧；</li><li>Share：分享一篇有观点和思考的技术文章。</li></ol><p>刚好其中一篇关于程序员修养的文章推荐了《97 Things Every Programmer Should Know》，有很多编程方面的建议，文章也都很经典，且都是英文文章，可以满足Review的内容，每周至少一篇，将该系列的文章翻译到自己的博客中，顺带提高自己的英文水平。没有商业目的，只为提升自己。</p><a id="more"></a><p>以下为我的文章链接:</p><a href="/2020/ckceme0r70008njxfdt10euqe/" title="程序员应该知道的97件事-1 三思而行">程序员应该知道的97件事-1 三思而行</a> <br><a href="/2020/ckceme0r50006njxfabeu4lg6/" title="程序员应该知道的97件事-2 应用函数式编程原则">程序员应该知道的97件事-2 应用函数式编程原则</a> <br><a href="/2020/ckcfwsxmd0000toxf8pbubn7a/" title="程序员应该知道的97件事-3 想想用户会怎么做">程序员应该知道的97件事-3 想想用户会怎么做</a> <br><a href="/2020/ckcom8une0003toxfdp0qcfqv/" title="程序员应该知道的97件事-4 自动化你的编码标准">程序员应该知道的97件事-4 自动化你的编码标准</a> <br><a href="/2020/ckcx1gc2s0000ydxfhksgh8qk/" title="程序员应该知道的97件事-5 美在简单之中">程序员应该知道的97件事-5 美在简单之中</a> <br><a href="/2020/ckczxqjo00000rbxf7obod820/" title="程序员应该知道的97件事-6 重构之前">程序员应该知道的97件事-6 重构之前</a> <br><a href="/2020/ckddwsgpo00007gxf6u1f5we1/" title="程序员应该知道的97件事-7 当心共享">程序员应该知道的97件事-7 当心共享</a> <br>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员应该知道的97件事-1 三思而行</title>
      <link href="/2020/ckceme0r70008njxfdt10euqe/"/>
      <url>/2020/ckceme0r70008njxfdt10euqe/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_01/" title="" target="">Act with Prudence</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>三思而行</span></h2><blockquote><p>不管你做什么，都应该三思而行且考虑后果</p><footer><strong>阿农</strong></footer></blockquote><p>在一次迭代的开始，不管日程表规划的多么舒服，有些时候都无法避免的面临压力。当面对“好好做”还是“快快做”的选择时，我们经常倾向于选择“快快做”，并告诉自己我之后会回来修复它。当对自己、团队以及客户做出这样承诺时，我们是认真的。但时常下一次迭代带来了新的问题，我们必须聚焦在新问题上。这种延迟的工作被称作“技术债务”，它是程序员的天敌。Martin Fowler把这种有意的技术债务收录到自己的技术债务分类中，以区分非主动的技术债务。</p><a id="more"></a><p>技术债务类似贷款：你短期内能从中获取收益，但在还清前不得不付利息给它。代码中走捷径会让它很难增加新功能或者进行重构。这是缺陷和脆弱测试案例的滋生源泉。留它越久，就会越糟糕。当着手解决最开始的那个问题时，摆在面前的是一系列“不太好的”设计导致了代码很难重构或者纠正问题。实际上，只有事情发展到不得不解决它时，我们才会回去修复问题。到那时经常修复问题变得很困难，以至于我们没有办法承担时间成本和风险。</p><p>大多数的技术债务来源于我们面临最后期限或者是非常简单的小需求。除非情况要求你必须这样，否则别让自己陷入这种境地。<span class='p red'>但是你一定要记录它，并且尽快回来修复掉</span>，否则你的情况很快变坏。只要你做了这种妥协的决定，就一定写下一个任务卡记录到你的追踪系统里，确定自己不会忘记。</p><p>要想损失最小，最好在下次迭代中规划修复工作。如果保留技术债务可以给你带来收益，那也要让这个收益的成本可见。这会在强调技术债务的商业价值时，将修复工作放在合适的优先级上。计算和追踪保留技术债务的收益需要具体项目具体分析，但是一定要记录下来。</p><p>尽快还清技术债务，否则是不明智的。</p><p>By <a href="https://www.linkedin.com/in/sebrose/" title="" target="">Seb Rose</a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><span class='p blue'>单词</span></h2><blockquote class="pullquote [class]"><p><span class='p green'>on the understanding that</span>  如果；在…条件下<br><span class='p green'>all too often</span>  时常，经常是<br><span class='p green'>breeding grounds</span>  滋生地<br><span class='p green'>get around to</span>  抽时间出来做…；开始考虑做…<br><span class='p green'>accrue</span>  v. 产生；自然增长或利益增加；积累<br><span class='p green'>imprudent</span> adj. 轻率的，鲁莽的；不明智的</p></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><span class='p blue'>个人观点</span></h2><p>技术债务是程序员无法逃避的问题，作者提到了这种有意为之的技术债务，来自于迭代的时间紧迫，或者功能简单，所以采用了不是最优的，但是能够快速实验的解决方案。在国内（不确定国外有没有)还有一个可能是这个人要离职（或者是离开项目）不会考虑后续维护之类的事情，留下了粗糙的代码。因此接手项目或者管理手下时，注意这样的情况，自身也尽量避免成为这样糟糕的程序员。</p>]]></content>
      
      
      <categories>
          
          <category> 英文文章翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员应该知道的97件事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客开篇</title>
      <link href="/2020/ckceme0r8000anjxfggylgltw/"/>
      <url>/2020/ckceme0r8000anjxfggylgltw/</url>
      
        <content type="html"><![CDATA[<p>Hexo博客第一篇，说说自己为什么要写博客，博客写什么东西，以及之后的计划。</p><a id="more"></a><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>开篇</span></h2><p>一晃都码农十年了，期间在外企打过工、在民企写过代码、创过业、当过外包老板，现在在某大公司安安稳稳的过着995生活。养孩子和供房子，加上疫情和经济大环境不好，没了折腾的动力和能力，索性安安稳稳中积累自己的能力，通过博客记录自己的学习过程，也作为一个输出的阵地，顺带提高下写作功力。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><span class='p blue'>写点啥</span></h2><p class='p left logo h4 green'>技术学习</p><p>虽然作为一个老码农，仍然还是有很多技术盲区，之后的学习不能局限于阅读，会通过博文内化为信手拈来的东西。当然还会有一部分是对英文内容的翻译（不是纯翻译，会改变为自己的语言)。</p><p class='p left logo h4 green'>非技术知识</p><p>一个人的知识结构应该像一架飞机，机身为自身专业能力，需要深入，飞机的机翼也是必不可少的，知识架构上代表了知识广度，这几年由于参加CPA考试，学习了很多财务分析知识；跟随得到也听了很多非常不错的经济、金融、管理的课程（还有些杂七杂八的内容）。看完听过之后，也会在博客上进行输出。 </p><p class='p left logo h4 green'>记录</p><ul><li>个人随笔，记录点感悟和日记；</li><li>儿童编程教育，我对其发展比较看好，因此会记录些自己的调研结果和想法；</li><li>如果可能，做些自己感兴趣的影视分析，热点评论。</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><span class='p blue'>咋计划</span></h2><p>2020年还会花费更多的时间去进行CPA备考，先计划“翻译翻译”《97 things every programmer should know》，随后不追求每月必须有多少篇，但是只要觉得有用我就会记录下来。</p><p class='p left logo h4'>奔着卓越努力！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
