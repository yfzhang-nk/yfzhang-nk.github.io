{"meta":{"title":"五灯","subtitle":"","description":"","author":"Yifei Zhang","url":"http://yfzhang-nk.github.io","root":"/"},"pages":[{"title":"关于我","date":"2020-06-26T08:48:35.000Z","updated":"2020-06-26T08:50:35.433Z","comments":true,"path":"about/index.html","permalink":"http://yfzhang-nk.github.io/about/index.html","excerpt":"","text":""},{"title":"Contributors 「鸣谢」","date":"2020-06-26T07:46:55.000Z","updated":"2020-06-26T08:21:53.697Z","comments":true,"path":"contributors/index.html","permalink":"http://yfzhang-nk.github.io/contributors/index.html","excerpt":"","text":"特别鸣谢 hexo 开发者和 Volantis 主题开发者，以及王庆彬的主题配置 Hexo volantis 王庆彬"},{"title":"所有分类","date":"2020-06-26T07:55:46.000Z","updated":"2020-06-26T07:57:43.055Z","comments":true,"path":"categories/index.html","permalink":"http://yfzhang-nk.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-26T08:01:36.000Z","updated":"2020-06-26T08:02:12.129Z","comments":true,"path":"tags/index.html","permalink":"http://yfzhang-nk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"程序员应该知道的97件事-12 编码即设计","slug":"code-is-design","date":"2021-01-18T07:19:26.000Z","updated":"2021-01-18T08:03:34.096Z","comments":true,"path":"2021/ckk2a7r790000fxxf62j91j4l/","link":"","permalink":"http://yfzhang-nk.github.io/2021/ckk2a7r790000fxxf62j91j4l/","excerpt":"","text":"原文链接: Code is Designhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_12/ 编码即设计想象一下，明早醒来或者建筑业取得了本世纪的突破，数以百万的廉价且速度惊人的机器人可以凭空制造材料，几乎零能源成本，还可以自我修复。更妙的是：只要一个明确的建筑蓝图，机器人就可以无需人工干预的情况下建造出来，成本可以忽略不计。 可以想象这对建筑业的影响，但上游会发生什么呢？如果建筑成本忽略不计，那建筑师和设计师的行为会有什么变化呢？今天在投资建设之前，物理模型和计算机模型都要被建立起来，并且经过严格测试。如果建筑是免费的，我们会介意吗？如果一个设计失败了，没什么大不了的–只要我们找到哪里错了，然后让神奇的机器人再建一个就行了。这里有很多深远影响。随着模型过时，未完成的设计通过接近最终目标的基础上反复建设和进化而不断发展。一个偶然的观察可能很难区分未完成的设计和成熟产品。 我们预测时间线的能力逐渐消失。建筑成本比设计成本容易计算–我们知道安装一根钢梁的大概成本以及我们需要多少根钢梁。随着可预测的任务减少，不可预测的设计时间开始占据主要地位。结果产生的越快，可靠的时间线越容易溜走。 当然，经济竞争压力依然存在。随着建筑成本减少，能够快速完成设计的公司就可以在市场上占据优势。快速完成设计变成了工程公司的核心推动力。不可避免的是，有些不熟悉设计的人就会看到一个未验证的版本，看到提前发布的市场优势，然后说“这看起来已经够好了”。 某些生死存亡的项目变得更加让人费劲心血，但是很多情况下消费者只能在未完成的设计里感受痛苦。公司总是派出神奇的机器人去“修补”他们卖出去的建筑和车辆。所有这些指向一个反直觉的惊人结论：我们唯一的前提是大幅度降低建筑成本，结果是质量越来越差。 上面的故事已经在软件行业上演了，这并不让我们感到惊讶。如果我们接受代码即设计–一个创造性的过程而不是机械化的过程–软件危机就能解释通了。我们现在有一个设计危机：对质量的要求，有效设计超过了我们创造它们的能力。使用未完成设计的压力很大。 幸运的是，我们如何变好，这个模型提供了一些线索。物理模拟等同于自动化测试；软件设计是不完整的直到我们通过一系列严苛测试验证了它。为了让这样的测试更有效，我们正在寻找控制大型系统的巨大状态空间的一些方法。改进的语言和设计实践给了我们希望。最终，有一个不可避免的事实：伟大的设计是由伟大设计致力于对他们手艺的掌握而被创造出来的。代码也不例外。 By Ryan Brush","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-11 使用领域内的语言编码","slug":"code-in-the-language-of-the-domain-md","date":"2020-11-23T09:25:30.000Z","updated":"2020-11-24T03:28:06.016Z","comments":true,"path":"2020/ckhudckf70000texff0jr4q4h/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckhudckf70000texff0jr4q4h/","excerpt":"原文链接: Code in the Language of the Domainhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_11/ 使用领域内的语言编码展示两端代码库。第一段如下: 12if (portfolioIdsByTraderId.get(trader.getId()) .containsKey(portfolio.getId())) &#123;...&#125; 你挠挠头，想只掉这段代码是做什么用的。看着好像是从一个trader对象里获取ID信息，显然是从一个map的map结构中获取一个map，然后看portfolio对象的ID是否存在于这个内部映射里。你更纳闷了，查询portfolioIdsByTraderId的定义，你会发现一下内容: 1Map&lt;int, Map&lt;int&gt;&gt; portfolioIdsByTraderId; 渐渐地，你可能意识到这可能跟一个trader拥有一个特定porfolio访问权有关。当然，你可能还会找到相同代码片段-或者相似但略有不同的代码-无论什么时候，只要一个trader想访问一个特定的portfolio。 另一段代码库如下: 1if (trader.canView(portfolio)) &#123;...&#125; 这次你不用疑惑了。你不需要知道trader是如何知道的。也许这里隐藏了很多map中包含map的结构在里面。那都是trader的逻辑，不是你的。","text":"原文链接: Code in the Language of the Domainhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_11/ 使用领域内的语言编码展示两端代码库。第一段如下: 12if (portfolioIdsByTraderId.get(trader.getId()) .containsKey(portfolio.getId())) &#123;...&#125; 你挠挠头，想只掉这段代码是做什么用的。看着好像是从一个trader对象里获取ID信息，显然是从一个map的map结构中获取一个map，然后看portfolio对象的ID是否存在于这个内部映射里。你更纳闷了，查询portfolioIdsByTraderId的定义，你会发现一下内容: 1Map&lt;int, Map&lt;int&gt;&gt; portfolioIdsByTraderId; 渐渐地，你可能意识到这可能跟一个trader拥有一个特定porfolio访问权有关。当然，你可能还会找到相同代码片段-或者相似但略有不同的代码-无论什么时候，只要一个trader想访问一个特定的portfolio。 另一段代码库如下: 1if (trader.canView(portfolio)) &#123;...&#125; 这次你不用疑惑了。你不需要知道trader是如何知道的。也许这里隐藏了很多map中包含map的结构在里面。那都是trader的逻辑，不是你的。 你平时更喜欢使用哪种风格编码？ 曾几何时，我们只有最基础的数据结构：比特、字节和字符(其实就是字节，但我们假装是字母和标点)。小数有些棘手因为十个数字在二进制中工作不好用，所以我们有几种大小的浮点类型。接下来是数组和字符串(特殊的数组)。然后我们有了栈、队列、哈希、链表、跳表以及很多让人兴奋的且真实世界不存在的数据结构。“计算机科学”就是花费大量精力完成将真实世界与限制性的数据结构映射起来。真正的大师还要知其所以然。 然后，我们有了用户自定义类型。好吧，这不是什么新闻，但它某种程度上改变了游戏。如果你的领域包含trader或者portfolio这样的概念，你可以用Trader和Portfolio这样的类型对他们进行建模。但是比这更重要的是，你还可以使用领域内术语对它们的关系建模。 如果你不是使用领域术语进行编码，而是创建了一套默认的(秘密的)协议，这里的int对应trader，而那里的int表示portfolio。(最好不要把他们搞混！)如果你想要使用算法片段表述一个业务概念（一些Trader不被允许查看一些Portfolio–这是非法), 在映射关系中找到一个存在的访问权限，这样做并没有给审计和合规人员带来任何帮助。 下一个程序员可能不知道这个秘密，所以为什么不让它更明确一些呢？使用一个键查询另一个键作为存在检查的方法并不是那么容易理解的。人们应该如何凭借直觉知道防止利益冲突的业务规则是在哪里实现的？ 代码明晰领域概念可以让其他程序员轻松收集到代码的意图，比按照他们对领域业务的理解改造算法要容易的多。这也意味着当领域模型的演进-随着你对领域业务的理解深入-你也比较容易修改代码。再加上良好的封装，规则很有可能只存在一个地方，你可以修改它，相关依赖代码不会有察觉。 数月后接手的程序员会感谢你，而且这个人可能就是你。","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"初识gitbook","slug":"gitbook-usage","date":"2020-10-10T09:37:38.000Z","updated":"2020-10-11T13:17:14.018Z","comments":true,"path":"2020/ckg65v53u000xjmxfa3hh0f96/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v53u000xjmxfa3hh0f96/","excerpt":"背景为了在实验上深耕下去，正在阅读一本英文版的实验书籍，突然有了翻译成中文版的想法，调研了下写书工具，发现gitbook是不错的选择，可以使用markdown，还有git进行版本管理，逼格满满。 安装由于gitbook基于node.js，首先需要保证你的机器上已安装好node，不属于主要内容，就不做介绍了。 然后开始安装gitbook，输入以下命令进行安装： 1$ npm install -g gitbook-cli 安装完成后，通过下列命令验证是否安装成功： 123$ gitbook -VCLI version: 2.3.2GitBook version: 3.0.0 更多命令参看 GitBook 安装文档https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md","text":"背景为了在实验上深耕下去，正在阅读一本英文版的实验书籍，突然有了翻译成中文版的想法，调研了下写书工具，发现gitbook是不错的选择，可以使用markdown，还有git进行版本管理，逼格满满。 安装由于gitbook基于node.js，首先需要保证你的机器上已安装好node，不属于主要内容，就不做介绍了。 然后开始安装gitbook，输入以下命令进行安装： 1$ npm install -g gitbook-cli 安装完成后，通过下列命令验证是否安装成功： 123$ gitbook -VCLI version: 2.3.2GitBook version: 3.0.0 更多命令参看 GitBook 安装文档https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md 开始写书创建并进入你要写书的目录，调用下面的命令： 12345$ gitbook initwarn: no summary file in this bookinfo: create README.mdinfo: create SUMMARY.mdinfo: initialization is finished 命令输出可以看出，命令执行后创建了两个文件README.md和SUMMARY.md，其中SUMMARY.md记录的是书的章节目录，添加几个章节： 12345# Summary* [前言](preface.md)* [Part I 入门主题](PartI&#x2F;preface.md) * [1.概述和实验动机](PartI&#x2F;1.IntroductionAndMotivation&#x2F;preface.md) 同时根据SUMMARY.md列出的文件创建出来： 123456789$ tree.├── PartI│ ├── 1.IntroductionAndMotivation│ │ └── preface.md│ └── preface.md├── README.md├── SUMMARY.md└── preface.md 现在就可以尝试看看效果了，运行如下命令： 123456789101112131415161718$ gitbook serveLive reload server started on port: 35729Press CTRL+C to quit ...info: 7 plugins are installedinfo: loading plugin &quot;livereload&quot;... OKinfo: loading plugin &quot;highlight&quot;... OKinfo: loading plugin &quot;search&quot;... OKinfo: loading plugin &quot;lunr&quot;... OKinfo: loading plugin &quot;sharing&quot;... OKinfo: loading plugin &quot;fontsettings&quot;... OKinfo: loading plugin &quot;theme-default&quot;... OKinfo: found 1 pagesinfo: found 1 asset filesinfo: &gt;&gt; generation finished with success in 0.5s !Starting server ...Serving book on http:&#x2F;&#x2F;localhost:4000 使用浏览器输入 http://localhost:4000 ，可以看到图中内容： 自此gitbook可以投入使用了，可以开始写书了。","categories":[{"name":"写作","slug":"写作","permalink":"http://yfzhang-nk.github.io/categories/%E5%86%99%E4%BD%9C/"}],"tags":[{"name":"gitbook","slug":"gitbook","permalink":"http://yfzhang-nk.github.io/tags/gitbook/"},{"name":"工具","slug":"工具","permalink":"http://yfzhang-nk.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"tool","slug":"tool","permalink":"http://yfzhang-nk.github.io/tags/tool/"}]},{"title":"程序员应该知道的97件事-10 谨慎选择工具","slug":"choose-your-tools-with-care","date":"2020-09-09T03:07:20.000Z","updated":"2020-11-24T03:33:26.564Z","comments":true,"path":"2020/ckg65v53z0016jmxf9kzrewmp/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v53z0016jmxf9kzrewmp/","excerpt":"原文链接: Choose Your Tools with Carehttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_10/ 谨慎选择工具现代应用很少是从头构建的，而是用现有工具组装而成的，比如组件、代码库和框架，原因有很多： 应用变得越来越大、越来越复杂，但是留给程序员开发它的时间却越来越短。为了更好的利用开发者的时间和智慧，最好让他们更多集中在商业逻辑代码上而不是基础架构的代码。 相比自己开发，广泛的使用组件和框架很可能减少Bug。 有很多高质量的软件在网络上可以找到免费且可用的版本，这就意味着你很可能花更少的钱雇到有足够兴趣又专业的开发者。 软件开发和维护是人力密集型的工作，所以购买比构建更便宜。","text":"原文链接: Choose Your Tools with Carehttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_10/ 谨慎选择工具现代应用很少是从头构建的，而是用现有工具组装而成的，比如组件、代码库和框架，原因有很多： 应用变得越来越大、越来越复杂，但是留给程序员开发它的时间却越来越短。为了更好的利用开发者的时间和智慧，最好让他们更多集中在商业逻辑代码上而不是基础架构的代码。 相比自己开发，广泛的使用组件和框架很可能减少Bug。 有很多高质量的软件在网络上可以找到免费且可用的版本，这就意味着你很可能花更少的钱雇到有足够兴趣又专业的开发者。 软件开发和维护是人力密集型的工作，所以购买比构建更便宜。 但是，为你的应用选择合适的工具组合是一件需要深思熟虑的棘手工作。事实上在做决定时，有以下几件事情你需要考虑： 不同工具可能依赖不同上下文的假设–比如周边的基础架构、控制模型、数据模型、通讯协议等，这很可能导致应用和工具之间架构的不匹配。这样的不匹配可能引起非法入侵或者其他变通法，使得代码更复杂而非必要。 不同工具拥有不同的生命周期，更新其中一个工具是一项及其复杂且耗时的任务，因为新功能、设计变化、甚至是修复Bug都可能会引起与其他工具的不兼容。工具越多问题越糟。 一些工具需要很复杂的配置，通常使用一个或多个XML文件，这会很快变得不可控。应用最终就会看起来像是由XML写的加上一些其他语言的零星代码。配置的复杂性让应用变得很难维护和扩展。 当代码严重依赖特定厂商产品时就会出现厂商锁定的现象，最终会在以下几方面受到限制：可维护性、性能、演化能力、价格等。 当你计划使用免费软件时，你会发现它并不完全免费。你可能需要购买商业支持，这些支持并不必然便宜。 许可条款很重要，尤其是开源软件。例如，很多公司不接受使用GNU协议的，因为它的病毒性质–基于它开发的软件必须公开源代码。 我个人有一个策略，用来减缓以上这些问题：从小应用开始仅使用觉得必要的工具。通常最初的关注点是消除低水平基础架构的编程，比如使用一些中间件替代套接字，然后根据需要增加。我也倾向于通过接口和分层的方式把外部工具从业务对象隔离开，这样我如果感受不太好用时，就可以更换工具。这个方法好处在于我通常获得一个更小的应用，使用的外部工具比预想的要少很多。","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-9 先检查你自己的代码","slug":"check-your-code-first","date":"2020-08-20T08:51:29.000Z","updated":"2020-08-21T12:18:10.482Z","comments":true,"path":"2020/ckg65v53y0014jmxfaxh0b2jy/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v53y0014jmxfaxh0b2jy/","excerpt":"原文链接：Check Your Code First before Looking to Blame Othershttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_09/ 责备别人之前先检查自己的代码程序员们经常很难相信自己的代码是有问题的。这是不太可能的，以至于我们总是觉得是编译器的问题。 然而事实上，代码问题是由编译器、解释器、操作系统、应用服务器、数据库、内存管理或者其他系统软件的bug引起的可能性非常少见。的确，这些bug存在，但是它们远没有我们想象中的普遍。 我曾经在优化一个循环变量时遇到过一个编译器错误，但是我却认为我的编译器和操作系统发生过很多次这样的错误。在这个过程中我浪费了很多时间，除了我自己的，还有支持人员和管理人员的时间，最终都证明是我的错误，这让我觉得很愚蠢。 假设这个工具被广泛的使用、功能成熟并且被应用到很多技术栈中，那应该是没有什么理由去怀疑它的质量。当然，如果这个工具刚刚发布、世界范围内很少人使用或者下载、0.1版本的开源软件，我们可能有好的理由去怀疑这个软件。同样，商业软件的alpha版本也可能受到怀疑。","text":"原文链接：Check Your Code First before Looking to Blame Othershttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_09/ 责备别人之前先检查自己的代码程序员们经常很难相信自己的代码是有问题的。这是不太可能的，以至于我们总是觉得是编译器的问题。 然而事实上，代码问题是由编译器、解释器、操作系统、应用服务器、数据库、内存管理或者其他系统软件的bug引起的可能性非常少见。的确，这些bug存在，但是它们远没有我们想象中的普遍。 我曾经在优化一个循环变量时遇到过一个编译器错误，但是我却认为我的编译器和操作系统发生过很多次这样的错误。在这个过程中我浪费了很多时间，除了我自己的，还有支持人员和管理人员的时间，最终都证明是我的错误，这让我觉得很愚蠢。 假设这个工具被广泛的使用、功能成熟并且被应用到很多技术栈中，那应该是没有什么理由去怀疑它的质量。当然，如果这个工具刚刚发布、世界范围内很少人使用或者下载、0.1版本的开源软件，我们可能有好的理由去怀疑这个软件。同样，商业软件的alpha版本也可能受到怀疑。 鉴于编译器bug很少见，把时间和精力放在寻找你自己代码上的错误，比证明编译器有问题要好的多。所有常用调试建议都试用：分离问题，终止调用，测试覆盖；检查调用约定、共享代码库、版本号；向其他人解释代码；注意堆栈污染和变量类型错误；在不同的机器上运行代码或者使用不同构建配置（调试或者发布）进行编译。 质疑你的或者其他人的设想。不同供应商的工具可能基于不同的设想去构建工具–相同供应商的也有可能不同的工具。当别人报告一个问题，你不能复现，就去看看他们是怎么操作的。他们有可能做了你从没想过的操作或者按照不同顺序进行了操作。 我有一个个人规则，如果有一个bug我查不到原因，我就会开始寻找编译器的原因，然后是查看堆栈错误。特别正确的做法是加一些跟踪代码，让问题显现出来。 多线程问题是引起bug的另一个原因，它会让你头发变白，对着机器大喊大叫。当系统是多线程的时候，支持简单代码的所有建议也成倍增加。想找出关于一致性的bug仅仅依赖于调试和单元测试是不行的，这个时候设计的简单性至关重要。 所以别着急找编译器的错误，记住夏洛克 福尔摩斯的建议: 除去不可能的，剩下的即使再不太可能，那也是真相。我更喜欢怪探德克的那句话：除去不太可能的，剩下的即使再不可能，那也是真相。 单词stub out 掐灭、踩熄paramount adj. 最重要的，主要的；至高无上的 n. 最高统治者 个人观点总结来说就是先从自身找问题，再去找别人的问题。经常被人用的代码问题肯定比你写代码出现问题的可能性要小的多，因为问题早都在初期被人找到并且修复了。","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-8 童子军规则","slug":"the-boy-scout-rule","date":"2020-08-14T08:34:56.000Z","updated":"2020-08-14T09:54:22.895Z","comments":true,"path":"2020/ckg65v5400018jmxf6jls01pr/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v5400018jmxf6jls01pr/","excerpt":"原文链接: The Boy Scout Rulehttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_08/ 童子军规则童子军有一条规则：总是保持营地比你发现它时还要干净。如果你发现地上一团糟，不管是谁弄脏的，你都要打扫干净。你有意为下一组露营者改善周围环境。事实上这条规则的原始版本是出自罗伯特·史蒂芬生·史密斯·贝登堡(童子军运动创始人)，内容是尝试让这个世界比你发现它的时候变的更好一点。 假如我们在代码中也遵循这条规则：总是在提交代码时比上次拿到的模块代码更整洁。不管谁是原始作者，假如我们总是做出努力去提高模块，即使每次一点点。那将会是什么结果呢？ 我认为如果我们遵循这条简单的规则，我们会看到软件系统持续恶化的终结。相反，我们的系统随着进化会越来越好。我们将看到团队将系统作为一个整体来对待，而不是各自手头的那一小部分。","text":"原文链接: The Boy Scout Rulehttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_08/ 童子军规则童子军有一条规则：总是保持营地比你发现它时还要干净。如果你发现地上一团糟，不管是谁弄脏的，你都要打扫干净。你有意为下一组露营者改善周围环境。事实上这条规则的原始版本是出自罗伯特·史蒂芬生·史密斯·贝登堡(童子军运动创始人)，内容是尝试让这个世界比你发现它的时候变的更好一点。 假如我们在代码中也遵循这条规则：总是在提交代码时比上次拿到的模块代码更整洁。不管谁是原始作者，假如我们总是做出努力去提高模块，即使每次一点点。那将会是什么结果呢？ 我认为如果我们遵循这条简单的规则，我们会看到软件系统持续恶化的终结。相反，我们的系统随着进化会越来越好。我们将看到团队将系统作为一个整体来对待，而不是各自手头的那一小部分。 我认为这个规则的要求并不过分。你不必在提交代码时让每个模块都完美。你只需要简单的让它比你获取代码时好那么一点。当然这意味着你添加的任何代码都必须是整洁的。这也意味着你提交模块时至少要整理其他一件事情。你可能简单优化了一个变量名称，或者把一个超大函数拆成了两个小函数。你可能修复了一个循环依赖，或者加了一个接口来解耦策略和细节。 坦率的讲，这对我来说再普通不过了，就像便后要洗手，或者把垃圾扔到垃圾筒里而不是扔到地上一样。的确，把代码搞遭的行为和乱扔垃圾一样不被社会所接受，都是不应该做的事情。 但是不止这些，关心你的代码是一件事情，关心团队的代码是另一件事情。团队应该互相帮助，互相整理。他们应该遵守童子军规则，因为它对所有人都好，不仅仅是对他们好。 By Uncle Bobhttps://blog.cleancoder.com/","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-7 当心共享","slug":"beware-the-share","date":"2020-07-31T09:21:57.000Z","updated":"2020-08-14T09:56:23.945Z","comments":true,"path":"2020/ckg65v53r000qjmxfb4w5ezpe/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v53r000qjmxfb4w5ezpe/","excerpt":"原文链接：Beware the Sharehttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_07/ 当心共享那是我在公司的第一个项目，我刚刚完成我的学位，急于证明自己，每天工作到很晚，检查已有的代码。当我做完第一个功能开发，我格外小心地把学到的所有东西落实到位，评论、日志、尽可能的抽离共享代码到库中。然后对我认为已经准备好的代码做评审时，使我意识到重用是不被赞同的。 怎么会这样呢？学校里重用被认为是高质量软件工程的缩影。我读过的文章和教科书，以及资深的软件工程师都是这样告诉我的。一切都错了吗？ 原来是我漏掉了一个关键信息： 上下文 系统中两个截然不同的部分以相同的方式执行某种逻辑，并没有我们想象中的那么重要。直到我把这些库中共享代码抽离出来为止，这些部分的代码互相是不依赖的。每一部分都可以独立演化。每一部分都可以修改自己的逻辑以满足系统日益变化的业务需求。四行相似的代码是偶然的–暂时的异常、一个巧合。直到我出现。","text":"原文链接：Beware the Sharehttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_07/ 当心共享那是我在公司的第一个项目，我刚刚完成我的学位，急于证明自己，每天工作到很晚，检查已有的代码。当我做完第一个功能开发，我格外小心地把学到的所有东西落实到位，评论、日志、尽可能的抽离共享代码到库中。然后对我认为已经准备好的代码做评审时，使我意识到重用是不被赞同的。 怎么会这样呢？学校里重用被认为是高质量软件工程的缩影。我读过的文章和教科书，以及资深的软件工程师都是这样告诉我的。一切都错了吗？ 原来是我漏掉了一个关键信息： 上下文 系统中两个截然不同的部分以相同的方式执行某种逻辑，并没有我们想象中的那么重要。直到我把这些库中共享代码抽离出来为止，这些部分的代码互相是不依赖的。每一部分都可以独立演化。每一部分都可以修改自己的逻辑以满足系统日益变化的业务需求。四行相似的代码是偶然的–暂时的异常、一个巧合。直到我出现。 我构建的共享代码就像把彼此的鞋带绑在了一起。这样的话，一个业务领域的步骤如果不与其他业务同步就不能被创建出来。功能独立的维护成本通常是微不足道的，但是通用库则需要多一个数量级的测试。 当我减少了系统中的代码行数，却增加了一堆的依赖。这些依赖的上下文很重要–如果已经被本地化了，那么它可能是合理的，并且有一些积极的价值。如果这些依赖关联不大，即使它们看起来很好，但也会使系统陷入更大的问题中。 这些错误是隐蔽的，因为它们的核心内容听起来像一个好主意。当应用到正确的上下文中，这些技术是有价值的。但是在错误的上下文中，它们增加的消耗比价值更大。当碰到一段已经存在的代码，不知道都是哪些不同部分在使用它，我对哪些内容该共享会更加小心。 当心共享代码。仔细检查上下文。只有这样才能继续。 By Udi Dahanhttps://www.linkedin.com/in/udidahan/?originalSubdomain=il 单词put in place 到位；落实到位；正在实施up until 一直到…为止negligible adj. 微不足道的，可以忽略的be held in check 牵制于人insidious adj. 阴险的；隐伏的；狡猾的 个人观点本文给人的启发就是抽取共用代码的时候要当心，有可能他们其实没有啥关系，只是代码看起来有点相似而已，作者给出了区分共享代码的关键判断点，看上下文。不过我个人觉得这是个正确的废话，判断上下文是否适合共享代码，还是会存在很大的主观性，实际情况还是会碰到扯皮的问题。","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-6 重构之前","slug":"before-you-refactor","date":"2020-07-23T08:11:52.000Z","updated":"2020-11-24T03:32:51.126Z","comments":true,"path":"2020/ckg65v53p000njmxf0bk3bbp3/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v53p000njmxf0bk3bbp3/","excerpt":"原文链接：Before You Refactorhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_06/ 重构之前某些时刻每个程序员需要重构已有的代码。但是在做重构之前请想清楚一下几点，这样会帮你和其他人省很多时间（或者痛苦）： 重构最好的方法应该从观察已有的代码库和相关测试案例。这会帮助你了解当前代码的优点和缺点，以保证能保留已有的优点和避免错误。我们都认为我们会比现有系统做的好…直到完成，发现我们有些事比以前做的并不比以前好，甚至更糟，因为我们没有从之前的错误中吸取教训。","text":"原文链接：Before You Refactorhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_06/ 重构之前某些时刻每个程序员需要重构已有的代码。但是在做重构之前请想清楚一下几点，这样会帮你和其他人省很多时间（或者痛苦）： 重构最好的方法应该从观察已有的代码库和相关测试案例。这会帮助你了解当前代码的优点和缺点，以保证能保留已有的优点和避免错误。我们都认为我们会比现有系统做的好…直到完成，发现我们有些事比以前做的并不比以前好，甚至更糟，因为我们没有从之前的错误中吸取教训。 避免重写所有的诱惑。最好重用尽量多的旧代码。不管代码多丑，但只要是被测试过和评审过的代码就可以重用。丢弃旧代码-尤其是已经上线的-意味着你丢弃了数月的测试和久经考验的代码，里面可能有很多背景和你不知道的缺陷修复。如果你不考虑这些，你写出来的代码就会出现很多难解的问题，而这些问题其实已经在旧代码中被修复了。这会浪费很多时间、精力和多年来获得的知识。 多次增量修改好于一次重大调整。增量调整可以让我们容易从反馈中（比如测试）获取对系统的影响。一次修改后出现上百个测试失败，肯定是不好的，这会导致我们感到挫折和压力，从而做出错误决定。一次两三个测试失败是容易处理的，提供更可管理性的方法。 每次迭代结束，保证现有测试案例通过是很重要的。如果现有测试不能充分覆盖你的变动，就要新增测试案例。没有经过应有的考虑就不要轻易抛弃旧代码的测试案例。表面上看其中一些测试可能并不适用新的设计，但是它们很值得深挖其中特殊测试案例存在的原因。 抛去个人喜好和自我。如果没有问题，为什么要去修复它？代码风格和结构不满足我们的喜好，不是一个好的重构理由。同样，你认为会比上一个程序员做的更好，这也不是一个好的理由。 追求新技术也不是重构的充分条件。最糟糕的重构原因就是当前代码已经远远落后今天最酷炫的技术，而且我们认为最新的语言和框架能做更多高级的事情。除非成本收益分析说明新语言或框架能够在功能性、维护性和创造性上产生重要提升，否则保持现状就好。 记住人总是会犯错的。重构永远不能保证新代码更好，或者和原来一样好。我曾经看到过，也经历过不少失败的重构。人非圣贤孰能无过。 By Rajith Attapattuhttps://www.linkedin.com/in/rajith-muditha-attapattu/ 单词take stock of 观察、估量temptation n. 引诱；诱惑物take … into account 考虑；重视；体谅gauge v. 测量；估计","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-5 美在简单之中","slug":"beauty-is-in-simplicity","date":"2020-07-21T08:24:33.000Z","updated":"2020-11-24T03:32:23.865Z","comments":true,"path":"2020/ckg65v53t000tjmxffnub04f1/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v53t000tjmxffnub04f1/","excerpt":"原文链接：Beauty Is in Simplicityhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_05/ 美在简单之中有一句格言是所有软件开发者应该知道并且牢记于心的： 风格、和谐、优雅、节奏之美取决于简单。 柏拉图 一言以蔽之，这句话概括出了软件开发者渴求的价值所在。","text":"原文链接：Beauty Is in Simplicityhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_05/ 美在简单之中有一句格言是所有软件开发者应该知道并且牢记于心的： 风格、和谐、优雅、节奏之美取决于简单。 柏拉图 一言以蔽之，这句话概括出了软件开发者渴求的价值所在。 对于代码，我们有很多追求的东西： 可读性 可维护性 开发速度 美感柏拉图想告诉我们实现这些品质的因素是简单。 什么是漂亮的代码？这是一个非常主观的问题。正像很多观念认知取决于我们的背景一样，美的感知也极大的依赖于我们的背景。学习艺术的人和学习科学的人对美有不同的视角（至少有这个倾向）。艺术专业的人更倾向于通过比较软件和艺术工作来寻找美感，科学专业的人更强调谈论对称和黄金比例，试图把事情简化为公式。以我的经验来看，简洁性是双方论证的基石。 想想你学习过的源代码。如果你还没有读过别人的代码，立刻停止读这篇文章，找一些开源的代码学习学习。真的，我是认真的！去网上搜索哪些知名专家写的代码，只要是你熟悉的语言就行。 你回来了？好的，我们说到哪了？哦，是的…我发现那些能引起我共鸣的、我认为漂亮的代码都有很多共性。其中最主要的就是简洁性。我发现应用或者系统不管有多复杂，每个独立部分都保持着简洁性。这些简单的对象都拥有相似的简洁性：单一职责、方法高内聚、方法命名自描述。有人认为5-10行一个短方法有点极端，甚至有些语言特性使得方法很难几行内实现功能。尽管如此，这样的简洁性应该是我们追求的目标。 漂亮代码的底线是简单。每个独立的部分都应该保持简单：拥有简单的职责，与系统其他部分保持简单的关联。通过干净整洁、可测试的代码，在系统的整个生命周期内保持高效的开发速度，这才是让我们的系统能够承受住时间考验的方法。美来源于简单，并因简单被人们发现。 By Jorn Olmheimhttps://www.linkedin.com/in/joelmheim/ 单词keep close to one’s heart(s) 牢记于心、放在心上aspire to 渴求formulae n. 公式（formula的复数)","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-4 自动化你的编码标准","slug":"automate-your-coding-standard","date":"2020-07-16T09:53:42.000Z","updated":"2020-11-24T03:32:04.402Z","comments":true,"path":"2020/ckg65v53o000ljmxfbo41dlov/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v53o000ljmxfbo41dlov/","excerpt":"原文链接：Automate Your Coding Standardhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_04/ 自动化你的编码规范你可能有过这样的经历，项目一开始时，每个人都有很多想法-我们称为新项目决议。这些决议经常会记录到文档里。关于代码的决议最终会称为项目的代码规范。在启动会议上，开发负责人会浏览文档，最好的情况，每个人都同意会尝试遵守它。然而，一旦项目开始，这些好的想法都会一个一个被抛弃。当最终交付项目时，代码看起来一团糟，没有人知道怎么变成这样的。 是什么时候变糟的？大概在启动会议时，项目成员有些不太在意，其他人没有理解这点，更糟糕的，有些人根本就不同意这些规范，可能已经开始计划不服从这些规范。最后，有些人抓住了重点而且也同意，但是当项目压力过高时，他们不得不放任不管规范了。格式良好的代码并不会在客户那里获得加分，他们只是想要更多功能。而且加入代码规范不是自动化的，遵守它是一项很无聊的任务。尝试下缩进一个排版混乱的类，你就能明白自动化的好处了。","text":"原文链接：Automate Your Coding Standardhttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_04/ 自动化你的编码规范你可能有过这样的经历，项目一开始时，每个人都有很多想法-我们称为新项目决议。这些决议经常会记录到文档里。关于代码的决议最终会称为项目的代码规范。在启动会议上，开发负责人会浏览文档，最好的情况，每个人都同意会尝试遵守它。然而，一旦项目开始，这些好的想法都会一个一个被抛弃。当最终交付项目时，代码看起来一团糟，没有人知道怎么变成这样的。 是什么时候变糟的？大概在启动会议时，项目成员有些不太在意，其他人没有理解这点，更糟糕的，有些人根本就不同意这些规范，可能已经开始计划不服从这些规范。最后，有些人抓住了重点而且也同意，但是当项目压力过高时，他们不得不放任不管规范了。格式良好的代码并不会在客户那里获得加分，他们只是想要更多功能。而且加入代码规范不是自动化的，遵守它是一项很无聊的任务。尝试下缩进一个排版混乱的类，你就能明白自动化的好处了。 既然有这些问题，我们为什么还要一开始就制定编码规范呢？使用统一的代码规范的一个原因是，可以避免某些人通过使用自己的编码风格“独占”一段代码。我们想要阻止开发者使用反模式，以此避免一些常见Bug。总之，代码规范能够使在项目中工作变的轻松，从头到尾都可以保持开发速度。达到这个效果的前提是每个人都遵守它，否则就没有用了，比如有的人使用三个空格缩进，另一些人用四个缩进。 有很丰富的工具被用来生成代码质量报告或者是文档化维护代码规范，但这都不能全面解决问题。一定要把它自动化，在任何地方尽可能的强制执行。以下有一些示例： 保证你的代码规范检查是构建过程中的一环，以此可以让每个人都能在编译的时候自动的运行一遍规范检查。 用静态代码分析工具去扫描一遍代码中非预期的反模式。一旦发现终止构建。 学习如何配置这些工具，以便你可以定制你自己的扫描策略。 不要只测量代码测试覆盖率，还要自动化的检查结果。同样的，一旦发现测试覆盖率过低，就终止构建。 尽量自动化所有你认为重要的地方。你不可能把所有你关心的点都自动化起来。有一些地方你无法做到标记或修复的，把它们写到一个指导手册里，作为代码规范自动化的补充，但是你要接受这个事实：你的同事可能不会那么严格遵守手册中的内容。 最后，代码规范应该是动态的而不是静态的。随着项目的演进，项目需求会变，一开始看起来很聪明的做法，几个月后就看起来没有那么必要了。 By Filip van Laenenhttps://github.com/filipvanlaenen 单词quite often 经常get underway 开始、启程in all 总之diligently 勤奋的，勤勉的 个人观点除了代码规范应该自动化外，其他东西也可以学习自动化的方式。比如公司的价值观，个人的思维模式（或者行为准则）。大脑需要慢系统才能完成的事情，借助自动化这个外脑，在快系统中就能够得出正确决定。","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-3 想想用户会怎么做","slug":"ask-what-would-the-user-do","date":"2020-07-10T07:36:01.000Z","updated":"2020-11-24T03:31:13.430Z","comments":true,"path":"2020/ckg65v52w0006jmxfg7m89rdj/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v52w0006jmxfg7m89rdj/","excerpt":"原文链接：Ask What Would the User Do? (You Are not the User)https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_03/ 问问“用户会怎么做”我们倾向于假设其他人和我们思考方式一样，但是他们不会。心理学家称这个现象叫做虚假同感偏差。当人们思考或者行事跟我们不一样时，我们潜意识上很容易在某种程度会给他们打上缺陷的标签。 这种偏见解释了程序员们为什么很难把自己放到用户的位置上，用户也不会像程序员一样想问题。首先，他们很少花时间使用电脑。他们不知道也不关心电脑如何工作。这就意味着程序员们解决问题时采用了一些习以为常的技术，用户们却不会使用。在页面接口上，用户不会识别出图示和线索，尽管这些是程序员们经常使用的。","text":"原文链接：Ask What Would the User Do? (You Are not the User)https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_03/ 问问“用户会怎么做”我们倾向于假设其他人和我们思考方式一样，但是他们不会。心理学家称这个现象叫做虚假同感偏差。当人们思考或者行事跟我们不一样时，我们潜意识上很容易在某种程度会给他们打上缺陷的标签。 这种偏见解释了程序员们为什么很难把自己放到用户的位置上，用户也不会像程序员一样想问题。首先，他们很少花时间使用电脑。他们不知道也不关心电脑如何工作。这就意味着程序员们解决问题时采用了一些习以为常的技术，用户们却不会使用。在页面接口上，用户不会识别出图示和线索，尽管这些是程序员们经常使用的。 找出用户是如何思考的最好办法就是观察他们。要求用户使用你开发的软件，完成一项任务。确保这是一个真正的任务：“加总一列数据”，“计算你上个月的收支”。避免太详细的任务，比如，请选择这些电子表格单元格，在下面输入一个求和公式，这个任务给了很大暗示。让用户说说他的操作流程。不要打断或者试图帮助他。要不停思考“他/她为什么这么做”。 你会注意到用户做的这些事情的核心都是类似的。他们试图采用相同的顺序完成任务，并且在相同的地方犯一样的错误。你就应该设计这个核心操作了。这个不同于设计会议，因为在那样的会议上，人们更倾向于听到“如果用户想…该怎么办？”。这会导致复杂的功能并不是用户想要的。观察他们减少这种问题。 你会碰到用户被卡住的情况，当你卡住时，你会到处看看；当用户被卡住时，他们只会缩小他们的关注点。对于他们来说在屏幕的其他地方看到解决方案就变得更困难。这就是为什么帮助文字对于用户交互设计是一个不好的解决方法。如果你必须添加指示或者说明文档，保证把它们放在对的地方，比如靠近会出现问题的区域。正因为用户有限的注意力，工具栏提示会比帮助文档有用的多。 用户往往会蒙混过关。他们找到一个有效的方法他们就会坚持这么用下去，而不管这个方法多复杂。所以最好给用户提供一个真正明显的方法，而不是提供两三捷径。你还会发现用户说他们想要的，和他们真正想要的之间存在差异。令人担忧的是收集用户需求的通用方法是问他们。这也是为什么说获取用户需求最好的办法是观察他们。花一小时观察用户比猜测用户想要什么能获取更多的信息。 By Giles Colbornehttps://book.douban.com/subject/5394309/ 单词for a start 首先；作为开始get stuck v. 受骗；被卡在…；被堵…muddle through 终于应付过去；混过去stick with 坚持；继续做；保持联系convoluted adj. 复杂的；费解的；旋绕的 个人观点“Users tend to muddle through”，这点我深有体会，曾经就有用户告诉我们，不这样做，他们也会有其他办法实现想要的功能，只是会复杂一些，用户并不是笨，只是懒，懒的去发现你设计的捷径，只要有一个方法能实现自己的要求，就可以了，没有必要花时间去找到更多方法。相反，用户使用了复杂的方法后，反而会抱怨我们太笨，为什么不那样设计，要绕这么大一个弯子。","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-2 应用函数式编程原则","slug":"apply-functional-programming-principles","date":"2020-07-09T08:18:42.000Z","updated":"2020-11-24T03:30:50.001Z","comments":true,"path":"2020/ckg65v52v0005jmxfhuzs9zyt/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v52v0005jmxfhuzs9zyt/","excerpt":"原文链接：Apply Functional Programming Principleshttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_02/ 应用函数式编程原则函数式编程(FP)最近又受到了主流编程社区的喜爱，部分原因是对于来自多核的挑战，函数范式的特性占有有利的位置。尽管这个原因的确是函数式编程很好的一个应用，但不是我给你推荐函数式编程的原因。 掌握函数式编程可以极大地提高你在其他上下文上写代码的质量。如果你能深入理解和应用函数范式，你的设计会拥有很高的引用透明性。","text":"原文链接：Apply Functional Programming Principleshttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_02/ 应用函数式编程原则函数式编程(FP)最近又受到了主流编程社区的喜爱，部分原因是对于来自多核的挑战，函数范式的特性占有有利的位置。尽管这个原因的确是函数式编程很好的一个应用，但不是我给你推荐函数式编程的原因。 掌握函数式编程可以极大地提高你在其他上下文上写代码的质量。如果你能深入理解和应用函数范式，你的设计会拥有很高的引用透明性。 引用透明性是一个很好的特性：表示一个函数针对相同的输入，始终产生相同的结果，而不管是在什么地方和什么时候调用。也就是说，函数的求值很少依赖（理想中是完全不依赖）可变状态的副作用。 命令式代码的主要缺陷来自可变的变量。读到这里的每个程序员都有这样的经历：在某个特殊情况下某些值不是期望的。可见性语义可以帮助我们减少这类问题，至少可以缩小范围，但真正的罪魁祸首是程序设计中滥用了变量。 在这个方面，我们确实没有从中获取太多帮助。面向对象默认使用这样的设计，因为他们经常展示由多个相关且长生命周期的对象图表组成的示例，美其名曰赋值方法，这样做其实是很危险的。但是，通过巧妙的测试驱动开发的设计，特别是确保“模拟职责，而不是对象”，可以消除不必要的可变性。 最终结果应该是这样一个设计：创建众多小函数，每个函数拥有自己的职责分配，按照输入的参数输出结果，而不是引用可变的成员变量。这样做产生的缺陷少，此外它们还容易调试，因为很容易定位该设计引入的标志值，比通过特定的上下文推断错误的赋值要好。这将大幅度增加引用透明性，想让这种意识深入骨髓，没有比学习函数式编程更好的办法了，因为这个在函数式编程中是作为标准出现的。 当然，这个方法不是在所有场景下都是最优的。比如，在面向对象系统中，这种风格在领域模型开发（例：打破商业规则的复杂度）上比用户界面开发更能产出更好的结果 掌握了函数式编程范式，你将更明智的把本章内容应用到其他领域。你的对象系统与引用透明性更能产生共鸣，跟函数式对等方式的接近程度超乎你的想象。实际上，有人断言函数式编程和面向对象编程是相互映射的两端，是计算机领域里的阴阳两极。 By Edward Garsonhttps://www.linkedin.com/in/egarson/ 单词be attributed to 归因于…culprit n. 犯人，罪犯act on 对…起作用；按照…行事rogue value 维基百科上显示为sentinel value的别名，表示标记值 个人观点函数式编程的特性我还没有深入的理解，此时不置评论。不过我相信，函数式编程有很好的特性，但软件工程上没有银弹，任何的设计都有适用的范围，使用前先深入了解它。","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"每个程序员应该知道的97件事","slug":"97things-every-programmer-should-know","date":"2020-07-08T07:33:53.000Z","updated":"2021-01-18T08:04:27.028Z","comments":true,"path":"2020/ckg65v52l0000jmxfg9jj8h0e/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v52l0000jmxfg9jj8h0e/","excerpt":"极客时间上购买了左耳听风的专栏，就是陈皓（左耳朵耗子）一个关于技术、成长、管理的文章合集，内容确实是丰富。 首先作者提供了一个程序员练级的方法，叫做ARTS，就是每周完成一个ARTS： Algorithm：每周至少做一道算法题； Review：阅读并点评至少一篇英文技术文章； Tip：学习至少一个技术技巧； Share：分享一篇有观点和思考的技术文章。 刚好其中一篇关于程序员修养的文章推荐了《97 Things Every Programmer Should Know》，有很多编程方面的建议，文章也都很经典，且都是英文文章，可以满足Review的内容，每周至少一篇，将该系列的文章翻译到自己的博客中，顺带提高自己的英文水平。没有商业目的，只为提升自己。","text":"极客时间上购买了左耳听风的专栏，就是陈皓（左耳朵耗子）一个关于技术、成长、管理的文章合集，内容确实是丰富。 首先作者提供了一个程序员练级的方法，叫做ARTS，就是每周完成一个ARTS： Algorithm：每周至少做一道算法题； Review：阅读并点评至少一篇英文技术文章； Tip：学习至少一个技术技巧； Share：分享一篇有观点和思考的技术文章。 刚好其中一篇关于程序员修养的文章推荐了《97 Things Every Programmer Should Know》，有很多编程方面的建议，文章也都很经典，且都是英文文章，可以满足Review的内容，每周至少一篇，将该系列的文章翻译到自己的博客中，顺带提高自己的英文水平。没有商业目的，只为提升自己。 以下为我的文章链接: 程序员应该知道的97件事-1 三思而行 程序员应该知道的97件事-2 应用函数式编程原则 程序员应该知道的97件事-3 想想用户会怎么做 程序员应该知道的97件事-4 自动化你的编码标准 程序员应该知道的97件事-5 美在简单之中 程序员应该知道的97件事-6 重构之前 程序员应该知道的97件事-7 当心共享 程序员应该知道的97件事-8 童子军规则 程序员应该知道的97件事-9 先检查你自己的代码 程序员应该知道的97件事-10 谨慎选择工具 程序员应该知道的97件事-12 编码即设计","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"程序员应该知道的97件事-1 三思而行","slug":"act-with-prudence","date":"2020-07-08T03:38:57.000Z","updated":"2020-11-24T03:30:13.838Z","comments":true,"path":"2020/ckg65v52r0001jmxf9jov4om8/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v52r0001jmxf9jov4om8/","excerpt":"原文链接：Act with Prudencehttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_01/ 三思而行不管你做什么，都应该三思而行且考虑后果 阿农 在一次迭代的开始，不管日程表规划的多么舒服，有些时候都无法避免的面临压力。当面对“好好做”还是“快快做”的选择时，我们经常倾向于选择“快快做”，并告诉自己我之后会回来修复它。当对自己、团队以及客户做出这样承诺时，我们是认真的。但时常下一次迭代带来了新的问题，我们必须聚焦在新问题上。这种延迟的工作被称作“技术债务”，它是程序员的天敌。Martin Fowler把这种有意的技术债务收录到自己的技术债务分类中，以区分非主动的技术债务。","text":"原文链接：Act with Prudencehttps://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_01/ 三思而行不管你做什么，都应该三思而行且考虑后果 阿农 在一次迭代的开始，不管日程表规划的多么舒服，有些时候都无法避免的面临压力。当面对“好好做”还是“快快做”的选择时，我们经常倾向于选择“快快做”，并告诉自己我之后会回来修复它。当对自己、团队以及客户做出这样承诺时，我们是认真的。但时常下一次迭代带来了新的问题，我们必须聚焦在新问题上。这种延迟的工作被称作“技术债务”，它是程序员的天敌。Martin Fowler把这种有意的技术债务收录到自己的技术债务分类中，以区分非主动的技术债务。 技术债务类似贷款：你短期内能从中获取收益，但在还清前不得不付利息给它。代码中走捷径会让它很难增加新功能或者进行重构。这是缺陷和脆弱测试案例的滋生源泉。留它越久，就会越糟糕。当着手解决最开始的那个问题时，摆在面前的是一系列“不太好的”设计导致了代码很难重构或者纠正问题。实际上，只有事情发展到不得不解决它时，我们才会回去修复问题。到那时经常修复问题变得很困难，以至于我们没有办法承担时间成本和风险。 大多数的技术债务来源于我们面临最后期限或者是非常简单的小需求。除非情况要求你必须这样，否则别让自己陷入这种境地。但是你一定要记录它，并且尽快回来修复掉，否则你的情况很快变坏。只要你做了这种妥协的决定，就一定写下一个任务卡记录到你的追踪系统里，确定自己不会忘记。 要想损失最小，最好在下次迭代中规划修复工作。如果保留技术债务可以给你带来收益，那也要让这个收益的成本可见。这会在强调技术债务的商业价值时，将修复工作放在合适的优先级上。计算和追踪保留技术债务的收益需要具体项目具体分析，但是一定要记录下来。 尽快还清技术债务，否则是不明智的。 By Seb Rosehttps://www.linkedin.com/in/sebrose/ 单词on the understanding that 如果；在…条件下all too often 时常，经常是breeding grounds 滋生地get around to 抽时间出来做…；开始考虑做…accrue v. 产生；自然增长或利益增加；积累imprudent adj. 轻率的，鲁莽的；不明智的 个人观点技术债务是程序员无法逃避的问题，作者提到了这种有意为之的技术债务，来自于迭代的时间紧迫，或者功能简单，所以采用了不是最优的，但是能够快速实验的解决方案。在国内（不确定国外有没有)还有一个可能是这个人要离职（或者是离开项目）不会考虑后续维护之类的事情，留下了粗糙的代码。因此接手项目或者管理手下时，注意这样的情况，自身也尽量避免成为这样糟糕的程序员。","categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"}]},{"title":"博客开篇","slug":"hello-world","date":"2020-07-07T09:31:51.416Z","updated":"2020-07-07T09:31:51.417Z","comments":true,"path":"2020/ckg65v53w0010jmxf083r124c/","link":"","permalink":"http://yfzhang-nk.github.io/2020/ckg65v53w0010jmxf083r124c/","excerpt":"Hexo博客第一篇，说说自己为什么要写博客，博客写什么东西，以及之后的计划。","text":"Hexo博客第一篇，说说自己为什么要写博客，博客写什么东西，以及之后的计划。 开篇一晃都码农十年了，期间在外企打过工、在民企写过代码、创过业、当过外包老板，现在在某大公司安安稳稳的过着995生活。养孩子和供房子，加上疫情和经济大环境不好，没了折腾的动力和能力，索性安安稳稳中积累自己的能力，通过博客记录自己的学习过程，也作为一个输出的阵地，顺带提高下写作功力。 写点啥技术学习 虽然作为一个老码农，仍然还是有很多技术盲区，之后的学习不能局限于阅读，会通过博文内化为信手拈来的东西。当然还会有一部分是对英文内容的翻译（不是纯翻译，会改变为自己的语言)。 非技术知识 一个人的知识结构应该像一架飞机，机身为自身专业能力，需要深入，飞机的机翼也是必不可少的，知识架构上代表了知识广度，这几年由于参加CPA考试，学习了很多财务分析知识；跟随得到也听了很多非常不错的经济、金融、管理的课程（还有些杂七杂八的内容）。看完听过之后，也会在博客上进行输出。 记录 个人随笔，记录点感悟和日记； 儿童编程教育，我对其发展比较看好，因此会记录些自己的调研结果和想法； 如果可能，做些自己感兴趣的影视分析，热点评论。 咋计划2020年还会花费更多的时间去进行CPA备考，先计划“翻译翻译”《97 things every programmer should know》，随后不追求每月必须有多少篇，但是只要觉得有用我就会记录下来。 奔着卓越努力！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yfzhang-nk.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yfzhang-nk.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"英文文章翻译","slug":"英文文章翻译","permalink":"http://yfzhang-nk.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"},{"name":"写作","slug":"写作","permalink":"http://yfzhang-nk.github.io/categories/%E5%86%99%E4%BD%9C/"},{"name":"随笔","slug":"随笔","permalink":"http://yfzhang-nk.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"程序员应该知道的97件事","slug":"程序员应该知道的97件事","permalink":"http://yfzhang-nk.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/"},{"name":"gitbook","slug":"gitbook","permalink":"http://yfzhang-nk.github.io/tags/gitbook/"},{"name":"工具","slug":"工具","permalink":"http://yfzhang-nk.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"tool","slug":"tool","permalink":"http://yfzhang-nk.github.io/tags/tool/"},{"name":"生活","slug":"生活","permalink":"http://yfzhang-nk.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}